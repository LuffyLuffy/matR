

<!DOCTYPE HTML>
<html>

<head>
<title>Using the matR Package</title>
</head>

<body>
<p>
<b>Purpose:</b> Learn what the matR package is, what it can do, how to install it, and where to find more information.
</p>

<p>
<b>Required Prerequisite Activities:</b> A current installation of the R language (>= 2.15) is required.
</p>

<p>
<b>Suggested Prerequisite Activities:</b> Gain some familiarity with R.  Online tutorials can be found at the <a href="http://www.r-project.org">R Language homepage</a>.  </p>

<p>
<b>Notes:</b> 
The following tutorial provides a brief overvie of matR functions. For a more detailed description of matR's capabilities, please see the <a href="">matR manual</a> </b>

<p>
<b>Related Tutorials:</b><a id="menu"> The following page presents a typical matR based analysis. The individual steps are highlighted below, you can proceed through them sequentially, or view each separately: </a>  



<p><a HREF="#introduction">Introduction</a></p>

<p><a HREF="#installation">Installation</a></p>
<p><a HREF="#collections">Collections</a></p>
<p><a HREF="#built_in_demo">Using built in demonstrations</a></p>
<p><a HREF="#built_in_data">Using built in data</a></p>
<p><a HREF="#download">Downloading data</a></p>
<p><a HREF="#norm-box">Data normalization and distribution vizualization with boxplots</a></p>
<p><a HREF="#grouping">Downloading data</a></p>
<p><a HREF="#pcoa">Generate 2 and 3 dimensional PCoAs</a></p>
<p><a HREF="#heat-dend">Generate heatmap-dendrogram</a></p>
<p><a HREF="#stats">Performing statistical tests</a></p>
<p><a HREF="#collections">Collections</a></p>
<p><a HREF="#metadata">Metadata</a></p>
<p><a HREF="#example">An additional analysis example</a></p>



<p></p>



<a id="introduction">
<h1>Introduction</h1>
</a>
matR is a client for analysis of metagenomic annotations built as an extension package to the popular R programming language for statistics.  It features facilities to build and examine metagenome collections, access to metadata, authentication for access to private data, customized analysis and visualization tools, and easy integration with the wide world of R extension packages.
<p><a HREF="#menu">menu</a></p>

<a id="installation">
<h1>Installation</h1>
</a>
At the R prompt, enter: 
<pre>
> install.packages ("matR", type = "source",
    repo = "http://dunkirk.mcs.anl.gov/~braithwaite/matR")
</pre>
And then, enter:
<pre>
> library (matR)
</pre>
to load the package, and finally enter:
<pre>
> dependencies ()
</pre>
to install supporting packages.  Note that in the technical sense there are no dependencies, but without supporting packages, many features will be unusable.
<p><a HREF="#menu">menu</a></p>


<a id="built_in_demo">
<h1>Using built-in demonstrations</h1>
</a>
MatR has a number of demonstrations built in for the purpose of exploring many of matR's capabilities.  To see built in demonstrations:
<pre>
> demo(package="matR")
</pre>
To run a demo, run the demo2 function with an analysis name returned from <i>demo(package="matR")</i>:
<pre>
> demo2("analyses")
</pre>
The demo2 function stops for each line of comment or code it returns for easy viewing. Press enter to proceed through each line in a demonstration
<p><a HREF="#menu">menu</a></p>

<a id="built_in_data">
<h1>Using built-in data sets</h1>
</a>
MatR has a number of datasets built in for the purpose of exploring matR's capabilities without having to download data.  To see built in datasets:
<pre>
> data(package="matR")
</pre>
To see the contents of a built in data set, simply type the name of the list (e.g.):
<pre>
> Marine
</pre>
To see a summary of the samples contained in the data set <i>samples(data_set_name)</i>, e.g.:
<pre>
>samples(Marine)
</pre>
<p><a HREF="#menu">menu</a></p>


<a id="download">
<h1>Downloading data</h1>
</a>
<p>Downlaoding enables users with a wide variety methods to access their abundance count data, dowloading them through the KBase API to data objects that are easily manipulated within R, with matR or any other R pacakges.</p>
<p>A typical download involves three steps:</p>
<p>(1) Creating a list of KBase/MG-RAST ids for the samples to be downloaded. Lists can be labeled or not.</p>
<p>Here is an example of creating a labeled list:</p>
<pre>
>my_list <- c("fresh1"="mgm4440424.3", "fresh2"="mgm4440423.3", "spring1"="mgm4441096.3", "spring2"="mgm4442583.3")
</pre>
Here, the sample list is created without labels:
<pre>
>my_list <- c("mgm4440424.3", "mgm4440423.3", "mgm4441096.3", "mgm4442583.3")
</pre>
<p>(2) Determining if you want to use the default matR download(the case considered directly below in 3a), or if you want to specifiy the parameters for your download(see 3b below). </p>
<p>(3a) To perform a default download, for the list created above:
<pre>
my_collection <- collection(my_list)
</pre>
<p>The content of default downloads will depend on the type of seqeunce data that was annotated.  Whole genome shotgun data return subsystem level3 ("named subsystems") counts; amplicon
data return species level abundance data by default.  Note that for all default downloads, 4 types of counts are returned, raw abunadnce values ("raw"), normlized abundance values "nrm", raw counts with singleton counts removed "nsc", and counts normalized after the removal of singleton counts "nsn". To view these four objects, use standard R referencing; e.g. to view the raw "count values: </p> 
<pre>
>my_collection$raw
</pre>
<p>(3b) To perform a custom download, you have to specify the parameter values for each download</p>
<p>You can see the complete list of parameters like this:</p>
<pre>
>view.params
</pre>
<p>If you wanted to download the level2 subsystem counts, this would work</p>
<pre>
>my_custom_collection <- collection(my_list, my_counts=c(entry="count", annot="func", level="level2", source="Subsystems"))
</pre>
<p>To view the counts, standard R referencing would be used:</p>
<pre>
>my_custom_collection$my_counts
</pre>
<p><a HREF="#menu">menu</a></p>


<a id="norm-box">
<h1>Data normalization and vizualizing data distributions</h1>
</a>
A critical consideration in all analyses of abundance data is how to treat the data with respect to normalization and scaling.
matR provides a simple function to all values in a single sample:

<p><a href="http://www.codecogs.com/eqnedit.php?latex=x*_{s,i} = \frac{x_{s,i} - \bar{x}} {\sigma _{s}}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?x*_{s,i} = \frac{x_{s,i} - \bar{x}} {\sigma _{s}}" title="x*_{s,i} = \frac{x_{s,i} - \bar{x}} {\sigma _{s}}" /></a></p> 
This procedure is outlined in <a HREF="http://catalog.loc.gov/cgi-bin/Pwebrecon.cgi?v3=1&ti=1,1&SEQ=20130417142822&Search_Arg=1-58488-327-8&Search_Code=STNO&CNT=100&PID=I61Qwpq77YeSlFk3loj6ROUmk80V&SID=1">Speed 2003 pp116-117</a>
After this procedure has been applied to values from each sample, all values in the data set are scaled from [min..max] to [0..1].
Briefly, each value (i) in a sample (s) is adjusted such that the mean of all values in the sample is 0 with a standard deviation of 1.
You can perform matR normalization this way if your data is a matR collection:
<pre> >normed_data <- normalize(my_collection$my_counts) </pre>
or this way if your data are in the form of a matrix:
<pre> >normed_data <- normalize(my_matrix) </pre>
<p>Before you generate visualizations from, or apply statistical anlayses to your data, t is crucial to look at the data distributions. The easiest way to do this is to use the R(base) boxplot function.</p>
<p>To produce a boxplot for the raw and normalized values used in the example above: </p>
<pre> >boxplot(my_collection$my_counts) </pre>
<pre> >boxplot(normed_data) </pre>
Note that in the first example, boxplot is applied to a matrix contained in a collection ( the matrix "my_counts" contained in the collection "my_collection").  In the second example, boxplot is applied directly to a matrix object ( "normed_data" )
<p>Observation of data distributions is an easy way to identify samples that may need to be culled (exhibit distributions that are too dissimilar from others), and can be used as a means to determine the class of statistical tests that  are most appropriate for the data (e.g. parametric tests for data that exhibit a normal distribution and non-parametric tests for data with non-normal distributions).  This is an extremely brief overview - users are encouraged to contact informatic statistical experts if there are any questions/doubts concerning data distributions and how they infomr data analyses. </p>
<p><a HREF="#menu">menu</a></p>

<a id="grouping">
<h1>Sample grouping</h1>
</a>
Segregation of samples with respect to metadata, or arbitrarily, defined groups is an essential precursor to most visulizations (e.g. heatmap dendrogram or PCoA), and all statistical tests. MatR will soon support 
automated metadata driven creation of sample groups.  For now, the process is manual.  Groups are added to collections in the following way:
<pre>
groups(my_collection) <- c(1,1,2,2)
</pre>
It is also possible to specify groups when a visualization or statistical analysis is performed.
<p><a HREF="#menu">menu</a></p>

<a id="pcoa">
<h1>Generate 2 and 3 dimensional PCoAs</h1>
<p>Using matR, it is easy to generate 2 and 3 dimmensional PCoAs.</p>
<p>Below are examples to produce 2 and 3 dimmensional PCoAs from built in data</p> 
</a>
<p>We use a prepackaged collection of 24 metagenomes (the "Waters" dataset), fifteen from a fresh water sample, the others from a hot spring.</p>
<pre>
> Waters
> samples (Waters)
</pre>
We can see that the first 15 samples are "<i>fresh</i>" water, the last 9 are "<i>spring</i>" 
We generate groupings with this information: 
<pre>
> groups (Waters) <- c (rep (1, 15), rep (2, 9))
</pre>
Now the first 15 samples are in group "1", the last 9 are in group "2" -- note that group names can be numerical or text.
Next we use the groupings to define colors for the PCoA plot:
<pre>
> col <- groups (Waters)
> levels (col) <- c ("blue", "red")
> col <- as.character (col)
</pre>
This created a "col" vector from the group numbers specified above, then changed each instance of "1" with "blue", "2" with "red"
Note that R doesn't <i>know</i> which samples should be red and blue -- it uses the order of values in the "col" vector to determine coloring
Now we can generate a simple 2 dimmensional PCoA - by default, we use the first two components (those that contain the largest amoung of variation in the data):
<pre>
> pco (Waters, comp = c (1,2), main = "fresh vs. spring water samples", col = col)
</pre>
Creating a 3 dimensional PCoA from the same data is easy:
<pre>
pco (Waters, comp = c (1,2,3), main = "fresh vs. spring water samples", color = col)
</pre>
There are a number of additional options that will allow you to create PCoAs with additional options - specifying the distance metric etc. These are outlined in the <a href="">matR manual</a>  
<p><a HREF="#menu">menu</a></p>

<a id="heat-dend">
<h1>Creating a heatmap-dendrogram</h1>
<p>Using matR, you can also generate heatmap dendrograms of your data.</p>
<p>Here we provide a simple a example using built-in data:</p>
<pre>
> heatmap (Waters)
</pre>
As with pcoa - there are a number of option that can be used to customize this visualization.  These are outlined in much greater detail in the 
<p><a HREF="#menu">menu</a></p>

<a id="stat">
<h1>Performing statistical tests</h1>
<p>One of the most useful features of matR is it's ability to perform multiple tests that have been optimized for metagenomic data.  In addition, users are encouraged to use other packages to perform desired tests on their data.</p>
<p>Here we provide simple examples of statistical tests built into matR using the built in "Waters" dataset.  The <a href="">matR manual</a> contains a much more complete and detailed description of all available statistical functions</p>
<p>A statistical test such as Kruskal-Wallis can help identify the most significant rows (annotations) and sharpen the picture:</p>
<pre>
> results <- sigtest (Waters, test = "Kruskal-Wallis")
</pre>
We can browse the test results:
<pre>
> head (results$sd)
> head (results$mean)
> head (results$stat)
</pre>
Using p-values, we check how many annotations are retained, at various significance levels:
<pre>
> sum (results$stat$p.value < 0.05)
> sum (results$stat$p.value < 0.005)
> sum (results$stat$p.value < 0.0005)
</pre>
It is easy to subselect, leaving abundance data for the eighteen functional annotations of highest significance in differentiating the two groups:
<pre>
> subm <- Waters$normed [results$stat$p.value < 0.0005, ]
> dimnames (subm)
> subm
</pre>
A heatmap restricted to these functions shows clear distinctions between fresh and spring water, but also a curious aberration in the ninth spring water sample:
<pre>
> heatmap (Waters, rows = (results$stat$p.value < 0.0005))
</pre>
We can scrutinize available metadata for an explanation, and after noticing the various projects contained in the collection, it seems natural to compare sample environments:
<pre>
> metadata (Waters) ["project.name"]
> metadata (Waters) ["4443745.3"]
> metadata (Waters) ["env_package"]
> metadata (Waters) ["sample.data"]
> metadata (Waters) ["temperature"]
</pre>
Nothing turns up, so we turn to library information:
<pre>
> metadata (Waters) ["library"]
</pre>
There, we discover that the ninth spring water sample, unlike every other in the collection and even in its own project, underwent Amplicon sequencing:
<pre>
> metadata (Waters) ["library.type"]
</pre>
At this point we may wish to continue analysis with subcollections, using WGS metagenomes, only:
<pre>
> Waters2 <- Waters [1:23]
</pre>
Or we may, to isolate a comparison of different sequencing technologies, select metagenomes only from the project that includes the Amplicon metagenome:
<pre>
> Waters3 <- Waters [19:24]
</pre>
For instance, we can redo the eighteen-row heatmap from above, with the Amplicon metagenome omitted:
<pre>
> groups (Waters2) <- c (rep (1, 15), rep (2, 8))
> results2 <- sigtest (Waters2, test = "Kruskal-Wallis")
> heatmap (Waters2, rows = (results2$stat$p.value < 0.0005))
</pre>
Significance testing could also be redone with annotations from a higher (or lower) level of the Subsystems hierarchy:
<pre>
> Waters$lev2 <- c (entry = "normed", level = "level2")
> results.lev2 <- sigtest (Waters, view = "lev2", test = "Kruskal-Wallis")
> heatmap (Waters, view = "lev2", rows = (results.lev2$stat$p.value < 0.005))
> rownames (Waters$lev2) [results.lev2$stat$p.value < 0.005]
</pre>
We added a new view to the collection, and proceeded as before.
<p><a HREF="#menu">menu</a></p>



<a id="collections">
<h1>Collections</h1>
</a>
Metagenome collections are constructed using metagenome IDs.  For example:
<pre>
> ids <- c ("4441679.3", "4441680.3", "4441682.3", "4441695.3", "4441696.3", "4440463.3", "4440464.3")
> cc <- collection (ids)
</pre>
This creates a collection object containing metadata and abundance data for the identified metagenomes.  Various functions apply to collections:
<pre>
> samples (cc)        # show ids of constituent metagenomes
> names (cc)          # show names of metagenomes
> views (cc)          # show the matrix views that the collection contains (see below)
> viewnames (cc)      # show just the names of the views
> metadata (cc)       # access metadata of the collection
</pre>
Views of collections are accessed with "$".   For example, this command shows raw abundance counts of functional annotations at level 3 of the Subsystems hierarchy:
<pre>
> cc$count
</pre>
while this shows the same data, but normalized to lie between 0 and 1:
<pre>
> cc$normed
</pre>
Generally, the purpose of views is to show different aspects of the same selection of metagenomes.  Views can be specified when a collection is constructed:
<pre>
> dd <- collection (ids, kegg = c (source = "KEGG"))
</pre>
and can also be added to an existing collection:
<pre>
> dd$cog <- c (source = "COG")
</pre>
Subsets can be taken of collections, as of regular vector objects.  For instance, a subcollection is created by
<pre>
> ee <- cc [1:4]
</pre>
that contains only the first four metagenomes.
</pre>
<p><a HREF="#menu">menu</a></p>

<a id="metadata">
<h1>Metadata</h1>
</a>
Metadata is a list of named elements with a hierarchical organization.  To select elements, an arbitrary number of index vectors may be specified.  For instance, we can use one index (of length one) to get all metadata from one metagenome:
<pre>
> mm <- metadata (cc)
> mm ["4440464.3"]
</pre>
Or we can use two indices, each of length one, to get certain elements from all metagenomes:
<pre>
> mm ["latitude", "longitude"]
</pre>
The following example uses one index of length two, to get the entire environmental package from one metagenome:
<pre>
> mm [c ("4440464.3", "env_package.data")]
</pre>
And this example uses three indices, all of length two, to select a miscellany of elements:
<pre>
> mm [c ("0464", "PI"), c ("0464","seq"), c ("0464","biome")]
</pre>
These are just examples to show the flexibility of indexing metadata.  One other convenient feature creates a data.frame with one row per metagenome, with this syntax:
<pre>
> mm ["host_common_name", "disease", ".age", bygroup = TRUE]
</pre>
If a requested metadata field is missing from a metagenome, NA is placed instead.
<p><a HREF="#menu">menu</a></p>


<a id="example">
<h1>Basic Analysis Example</h1>
</a>
A very large library of statistical tools is available in the R language.   matR provides convenient wrappings of some useful procedures and visualizations.  The following examples use prepackaged datasets.
<p>
<!--<img alt="" src="boxplot.svg"><br>-->
Boxplots usefully summarize diversity, with this command:
<pre>
> render (Coral, view="count")
> render (Coral, view="normed")
</pre>
<!--<img alt="" src="pco.svg"><br>-->
A principal components analysis is plotted in two or three dimensions, and grouped by color, this way:
<pre>
> g <- factor (metadata (Hospital) ["ventilation_type"])
> col <- g
> levels (col) <- c ("red", "blue", "orange")
> col <- as.character (col)
> pco (Hospital, comp = c (1,2), col = col, labels = g)
> P <- pco (Hospital, comp = c (1,2,3), color = col, labels = g)
</pre>
The numerical results of the analysis are stored in the object P.
<p>
<!--<img alt="" src="heatmap1.svg"><br>-->
A heatmap gives a quick visual summary of annotations, as well suggesting further investigations:
<pre>
> heatmap (Guts, cexCol = 0.9)
</pre>
Significance testing of annotations is the starting point for detailed analysis.  The following routine calculates the significance of each annotation in establishing a specified grouping of samples, by the Kruskal-Wallis test.  Then, a heatmap is made of only the rows passing a specified significance threshold.
<!--<img alt="" src="heatmap2.svg"><br><br>-->
<pre>
> groups(Waters) <- c (rep (1, 15), rep (2, 9))
> results <- sigtest (Waters, test = "Kruskal-Wallis")
> heatmap (Waters, rows = (results$stat$p.value < 0.005), main = "annotations at p < 0.005")
</pre>
Such analyses can be fruitfully iterated.

<p>This provides a simple example ofthe type of analyses that can be performed with matR. </p>
<p>Users are strongly encourage to view the <a href="">matR manual</a> for a more detailed description of all functions and capabilities.</p>

<p><a HREF="#menu">menu</a></p>

<h1>Integration</h1>
matR integrates easily with other R software.  Collection views are directly extracted as ordinary matrices with the $ operator, as above.  Metadata is an S3-classed character vector.  Visualization routines accept all standard graphical parameters.  Shortcuts are provided to write collection data and analyses to text files.

<h1>Further Resources</h1>
Once the package is loaded in an R session, use:
<pre>
> demo (package = "matR")
</pre>
for a list of short tutorial demos.  Run these with the regular R command demo() or the enhanced version demo2(), for instance:
<pre>
> demo2 ("metadata")
</pre>
To list prepackaged datasets, use:
<pre>
> data (package = "matR")
</pre>

</body>
</html>
